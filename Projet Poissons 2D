import numpy as np


class Simulation :
    
    def __init__(self, liste_de_poissons, liste_de_predateurs, N):
        self.liste_de_poissons = liste_de_poissons
        self.liste_de_predateurs = liste_de_predateurs
        self.N = N
        
    def voisin_le_plus_proche(self, p, i): 			# i est l'indice temporel concerné de la matrice positions
        poisson_1 = self.liste_de_poissons[p]		# p est l'indice du poisson concerné dans liste_de_poissons
        poisson_voisin = None
        distance_min = np.inf
        for n in range(len(self.liste_de_poissons)):
            if n != p :
                poisson_2 = self.liste_de_poissons[n]
                distance = poisson_1.distance(poisson_2, i)
                if distance < distance_min :
                    distance_min = distance
                    poisson_voisin = poisson_2
        return poisson_voisin
                    
    def centre_masse_poisson(self, i): # i est l'indice temporel concerné de la matrice positions
        point_centre = np.zeros((2))
        for poisson in self.liste_de_poissons :
            point_centre += poisson.positions[i]
        point_centre = point_centre / len(self.liste_de_poissons)
        return point_centre
        
                                     # A FAIRE
    #def vitesse_banc_poisson



class Boid :
    
    def __init__(self, position_initiale, vitesse_initiale, N, dt):
        self.N = N
        self.dt = dt
        self.initialisation_matrices(position_initiale, vitesse_initiale)
        
    def initialisation_matrices(self, position_initiale, vitesse_initiale):
        self.positions = np.zeros((self.N+1, 2))
        self.vitesses = np.zeros((self.N+1, 2))
        self.accelerations = np.zeros((self.N+1, 2))
        
        self.positions[0] = position_initiale
        self.vitesses[0] = vitesse_initiale

    def __str__(self):
        text = "Positions :\n" + str(self.positions) + "\nVitesses :\n" + str(self.vitesses) + "\nAccelerations :\n" + str(self.accelerations)
        return text

    def distance(self, boid, i): 	#distance avec un boid à l'indice i
        diff_position = self.positions[i] - boid.positions[i]
        norme = np.linalg.norm(diff_position)
        return norme


class Poisson(Boid):
    
    def __init__(self, position_initiale, vitesse_initiale, R_attraction_poisson, R_repulsion_poisson, v_max, N, dt):
        super().__init__(position_initiale, vitesse_initiale, N, dt)
        self.R_attraction_poisson = R_attraction_poisson
        self.R_repulsion_poisson = R_repulsion_poisson
        self.v_max = v_max



def jeu_de_test():
  poisson1 = Poisson([-1, -2], [0, 0], 10, 3, 20, 5, 0.1)
  poisson2 = Poisson([2, 2], [0, 0], 10, 3, 20, 5, 0.1)
  poisson3 = Poisson([0, 0], [1, 0], 10, 3, 20, 5, 0.1)
  
  la_simu = Simulation([poisson1, poisson2, poisson3], [], 5)
  
  print(poisson1)
  print()
  print(poisson2)
  print()
  
  distance = poisson1.distance(poisson2, 0)
  print(distance)
  print()
  
  poisson_voisin = la_simu.voisin_le_plus_proche(0, 0)
  print(poisson_voisin)

